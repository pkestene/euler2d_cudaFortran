!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Author: P. Kestener, CEA Saclay
!!
!!
!! This software is governed by the CeCILL license under French law and
!! abiding by the rules of distribution of free software.  You can  use,
!! modify and/ or redistribute the software under the terms of the CeCILL
!! license as circulated by CEA, CNRS and INRIA at the following URL
!! "http://www.cecill.info".
!!
!! The fact that you are presently reading this means that you have had
!! knowledge of the CeCILL license and that you accept its terms.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!< Defines all variables needed to perform computations
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
module HydroRun_gpu

  use HydroPrecision
  use HydroConstants
  use HydroParameters
  use HydroParameters_gpu
  use HydroUtils_gpu
  use Monitoring_gpu
  use m_nvtx

  use cudaFor

  ! defines data arrays

  ! host arrays
  real(fp_kind), dimension(:,:,:), allocatable :: h_u !< conservative variables

  ! device arrays
  real(fp_kind), dimension(:,:,:), allocatable, device :: d_u, d_u2 !< conservative variables
  real(fp_kind), dimension(:,:,:), allocatable, device :: d_q       !< primitive variables (implementation version 1 only)

  real(fp_kind), dimension(:,:,:), allocatable, device :: d_qm_x, d_qm_y !< input to Riemann solvers (implementation version 1 only)
  real(fp_kind), dimension(:,:,:), allocatable, device :: d_qp_x, d_qp_y !< input to Riemann solvers (implementation version 1 only)

  real(fp_kind), dimension(:,:,:), allocatable, device :: d_fx, d_fy !< Riemann fluxes (implementation version 2 only)


  ! cuda kernel parameters
#ifdef USE_DOUBLE
  ! for double precision
  integer, parameter ::  UNSPLIT_BLOCK_DIMX_2D=16, UNSPLIT_BLOCK_INNER_DIMX_2D=12
  integer, parameter ::  UNSPLIT_BLOCK_DIMY_2D=12, UNSPLIT_BLOCK_INNER_DIMY_2D=8
#else
  ! for single precision
  integer, parameter ::  UNSPLIT_BLOCK_DIMX_2D=32, UNSPLIT_BLOCK_INNER_DIMX_2D=28
  integer, parameter ::  UNSPLIT_BLOCK_DIMY_2D=12, UNSPLIT_BLOCK_INNER_DIMY_2D=8
#endif

  ! compute primitive variables kernel parameters (v1)
  integer, parameter ::  PRIM_VAR_BLOCK_DIMX_2D_V1=16
  integer, parameter ::  PRIM_VAR_BLOCK_DIMY_2D_V1=16

  ! compute trace kernel parameters (v1)
  integer, parameter ::  TRACE_BLOCK_DIMX_2D_V1=16, TRACE_BLOCK_INNER_DIMX_2D_V1=14
  integer, parameter ::  TRACE_BLOCK_DIMY_2D_V1=16, TRACE_BLOCK_INNER_DIMY_2D_V1=14

  ! compute update kernel parameters (v1)
  integer, parameter ::  UPDATE_BLOCK_DIMX_2D_V1=16, UPDATE_BLOCK_INNER_DIMX_2D_V1=15
  integer, parameter ::  UPDATE_BLOCK_DIMY_2D_V1=16, UPDATE_BLOCK_INNER_DIMY_2D_V1=15

  ! update compute fluxes and store (v2)
  integer, parameter ::  CMP_FLX_STORE_BLOCK_DIMX_2D_V2=32
  integer, parameter ::  CMP_FLX_STORE_BLOCK_DIMY_2D_V2=6

  ! update hydro (v2)
  integer, parameter ::  UPDATE_HYDRO_BLOCK_DIMX_2D_V2=32
  integer, parameter ::  UPDATE_HYDRO_BLOCK_DIMY_2D_V2=6

  ! external boundaries
  integer, parameter :: BOUNDARY_BLOCK_SIZE=128

  integer(int_kind) :: nStep=0

contains

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine initHydroRun

    implicit none


    ! memory allocation
    allocate( h_u (isize, jsize, nbVar) )
    allocate( d_u (isize, jsize, nbVar) )
    allocate( d_u2(isize, jsize, nbVar) )

    if (implementationVersion .eq. 1) then
       allocate( d_q   (isize, jsize, nbVar) )
       allocate( d_qm_x(isize, jsize, nbVar) )
       allocate( d_qm_y(isize, jsize, nbVar) )
       allocate( d_qp_x(isize, jsize, nbVar) )
       allocate( d_qp_y(isize, jsize, nbVar) )
    end if

    if (implementationVersion .eq. 2) then
       allocate( d_q (isize, jsize, nbVar) )
       allocate( d_fx(isize, jsize, nbVar) )
       allocate( d_fy(isize, jsize, nbVar) )
    end if

    ! initialize u (at t=0)
    select case (problem)
    case('implode') ! discontinuity line along the domain diagonal
       call init_implode(h_u)
    case default
       write(*,*) 'Unknown problem; default to implode'
       call init_implode(h_u)
    end select

    !! upload date into GPU memory
    d_u  = h_u
    d_u2 = d_u

  end subroutine initHydroRun

  ! !!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine cleanupHydroRun

    implicit none

    ! memory free
    deallocate(h_u,d_u,d_u2)

    if (implementationVersion .eq. 1) then
       deallocate(d_q,d_qm_x,d_qm_y,d_qp_x,d_qp_y)
    end if

    if (implementationVersion .eq. 2) then
       deallocate(d_q, d_fx, d_fy)
    end if

  end subroutine cleanupHydroRun

  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine compute_dt_cpu(dt)
    implicit none

    ! dummy variables
    real   (fp_kind) , intent(out)  :: dt

    ! local variables
    real(fp_kind) :: invDt=0.0
    real(fp_kind) :: vx,vy
    integer :: i,j
    real(fp_kind), dimension(nbVar) :: uLoc,qLoc
    real(fp_kind)                   :: c,p,e,eken

    ! for loop over inner region
    !do j=ghostWidth+1,jsize-ghostWidth
    !do i=ghostWidth+1,isize-ghostWidth

    do j=1,jsize
       do i=1,isize

          if (   j>ghostWidth .and. j<=jsize-ghostWidth .and. &
               & i>ghostWidth .and. i<=isize-ghostWidth       ) then

             ! retrieve u local
             uLoc(ID) = h_u(i,j,ID)
             uLoc(IP) = h_u(i,j,IP)
             uLoc(IU) = h_u(i,j,IU)
             uLoc(IV) = h_u(i,j,IV)

             ! compute primitives
             qLoc(ID) = max(uLoc(ID), smallr)
             qLoc(IU) = uLoc(IU) / qLoc(ID)
             qLoc(IV) = uLoc(IV) / qLoc(ID)

             eken = 0.5 * (qLoc(IU) * qloc(IU) + qLoc(IV) * qLoc(IV))
             e = uLoc(IP) / qLoc(ID) - eken

             ! retrieve pressure and sound speed from equation of state
             p = max ( (gamma0 - 1.0) * qLoc(ID) * e, qLoc(ID) * smallp)
             c = sqrt(  gamma0 * p / qLoc(ID))

             vx = c + abs(qLoc(IU))
             vy = c + abs(qLoc(IV))
             invDt = max(invDt, vx/dx + vy/dy)

          end if

       end do
    end do

    dt = cfl / invDt

  end subroutine compute_dt_cpu

  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! Compute time step reduction
  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine compute_dt(dt, useU)
    implicit none

    ! dummy variables
    real   (fp_kind) , intent(out)  :: dt
    integer(int_kind), intent(in)   :: useU

    ! local variables
    real(fp_kind) :: invDt=0.0
    integer       :: i,j,k

    real(fp_kind) :: vx,vy
    !real(fp_kind), dimension(nbVar), device :: qLoc
    !real(fp_kind), dimension(nbVar), device :: uLoc
    real(fp_kind) :: qLoc_ID,qLoc_IP,qLoc_IU,qLoc_IV
    real(fp_kind) :: uLoc_ID,uLoc_IP,uLoc_IU,uLoc_IV
    real(fp_kind) :: c
    real(fp_kind) :: eken ! kinetic energy
    real(fp_kind) :: e    ! total energy
    real(fp_kind) :: p

    call nvtxStartRange("compute_dt",1)

    ! for loop over inner region
    if (useU == 0) then

       !$cuf kernel do(2) <<< (*,*), (*,*) >>>
       do j=1,jsize
          do i=1,isize

             if (   j>ghostWidth .and. j<=d_jsize-ghostWidth .and. &
                  & i>ghostWidth .and. i<=d_isize-ghostWidth       ) then

                ! retrieve u local
                uLoc_ID = d_u(i,j,ID)
                uLoc_IP = d_u(i,j,IP)
                uLoc_IU = d_u(i,j,IU)
                uLoc_IV = d_u(i,j,IV)

                ! compute primitives
                qLoc_ID = max(uLoc_ID, d_smallr)
                qLoc_IU = uLoc_IU / qLoc_ID
                qLoc_IV = uLoc_IV / qLoc_ID

                eken = 0.5 * (qLoc_IU * qloc_IU + qLoc_IV * qLoc_IV)
                e = uLoc_IP / qLoc_ID - eken

                ! retrieve pressure and sound speed from equation of state
                p = max ( (d_gamma0 - 1.0) * qLoc_ID * e, qLoc_ID * d_smallp)
                c = sqrt(  d_gamma0 * p / qLoc_ID)

                vx = c + abs(qLoc_IU)
                vy = c + abs(qLoc_IV)
                invDt = max(invDt, vx/d_dx + vy/d_dy)

             end if

          end do
       end do

    else

       !$cuf kernel do(2) <<< (*,*), (*,*) >>>
       do j=1,jsize
          do i=1,isize

             if (   j>ghostWidth .and. j<=d_jsize-ghostWidth .and. &
                  & i>ghostWidth .and. i<=d_isize-ghostWidth       ) then

                ! retrieve u local
                uLoc_ID = d_u2(i,j,ID)
                uLoc_IP = d_u2(i,j,IP)
                uLoc_IU = d_u2(i,j,IU)
                uLoc_IV = d_u2(i,j,IV)

                ! compute primitives
                qLoc_ID = max(uLoc_ID, d_smallr)
                qLoc_IU = uLoc_IU / qLoc_ID
                qLoc_IV = uLoc_IV / qLoc_ID

                eken = 0.5 * (qLoc_IU * qloc_IU + qLoc_IV * qLoc_IV)
                e = uLoc_IP / qLoc_ID - eken

                ! retrieve pressure and sound speed from equation of state
                p = max ( (d_gamma0 - 1.0) * qLoc_ID * e, qLoc_ID * d_smallp)
                c = sqrt(  d_gamma0 * p / qLoc_ID)

                vx = c + abs(qLoc_IU)
                vy = c + abs(qLoc_IV)
                invDt = max(invDt, vx/d_dx + vy/d_dy)

             end if

          end do
       end do

    end if

    dt = cfl / invDt

    call nvtxEndRange()

  end subroutine compute_dt

  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! Wrapper to the actual computation routine
  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine godunov_unsplit(dt)

    implicit none

    ! dummy variables
    real(fp_kind), intent(in) :: dt

    call nvtxStartRange("godunov_compute",0)

    if ( modulo(nStep,2) == 0 ) then
       call godunov_unsplit_gpu(d_u , d_u2, dt)
    else
       call godunov_unsplit_gpu(d_u2, d_u , dt)
    end if

    call nvtxEndRange()

  end subroutine godunov_unsplit

  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! Actual GPU computation of Godunov scheme
  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine godunov_unsplit_gpu(data_in, data_out, dt)

    !use Monitoring

    implicit none

    ! dummy variables
    real(fp_kind), dimension(isize, jsize, nbVar), intent(inout), device :: data_in
    real(fp_kind), dimension(isize, jsize, nbVar), intent(inout), device :: data_out
    real(fp_kind)                                , intent(in), value     :: dt

    ! local variables
    integer :: i, j, ii, jj, iVar, ierr

    real(fp_kind) :: dtdx
    real(fp_kind) :: dtdy

    ! Local variables for trace computation
    ! we need to store qm/qp for current position i,j and i-1,j and i,j-1
    ! that is 1+2=3 positions in total
    real(fp_kind), dimension(3, nbVar) :: qm_x
    real(fp_kind), dimension(3, nbVar) :: qm_y

    real(fp_kind), dimension(3, nbVar) :: qp_x
    real(fp_kind), dimension(3, nbVar) :: qp_y

    real(fp_kind), dimension(nbVar)    :: qLoc ! local primitive variables
    real(fp_kind), dimension(4, nbVar) :: qNeighbors

    real(fp_kind), dimension(2, nbVar) :: qm, qp
    real(fp_kind)                      :: c, cPlus, cMinus
    integer :: pos

    ! Local variables for Riemann problems solving
    real(fp_kind), dimension(nbVar) :: qleft
    real(fp_kind), dimension(nbVar) :: qright
    real(fp_kind), dimension(nbVar) :: qgdnv
    real(fp_kind), dimension(nbVar) :: flux_x
    real(fp_kind), dimension(nbVar) :: flux_y

    type(dim3) :: dimGrid, dimBlock

    dtdx = dt / dx
    dtdy = dt / dy

    ! fill ghost cell in data_in
    call cudaTimerStart(d_boundaries_timer)
    call make_boundaries_gpu(data_in)
    call cudaTimerStop(d_boundaries_timer)

    ! copy data_in into data_out (not necessary)
    data_out = data_in

    ! start main computation
    call cudaTimerStart(d_godunov_timer)

    if (implementationVersion == 0) then

       ! Create the grid and block dimensions
       dimBlock = dim3( UNSPLIT_BLOCK_DIMX_2D, UNSPLIT_BLOCK_DIMY_2D, 1 )
       dimGrid  = dim3( &
            & (isize+UNSPLIT_BLOCK_INNER_DIMX_2D-1)/UNSPLIT_BLOCK_INNER_DIMX_2D, &
            & (jsize+UNSPLIT_BLOCK_INNER_DIMY_2D-1)/UNSPLIT_BLOCK_INNER_DIMY_2D, 1)
       call kernel_godunov_unsplit_2d_v0<<<dimGrid,dimBlock>>>(data_in, data_out, dt)

    else if (implementationVersion == 1) then

       ! convert conservative variable into primitives ones for the entire domain
       call nvtxStartRange("convertToPrimitives",2)
       dimBlock = dim3( PRIM_VAR_BLOCK_DIMX_2D_V1, PRIM_VAR_BLOCK_DIMY_2D_V1, 1 )
       dimGrid  = dim3( &
            & (isize+PRIM_VAR_BLOCK_DIMX_2D_V1-1)/PRIM_VAR_BLOCK_DIMX_2D_V1, &
            & (jsize+PRIM_VAR_BLOCK_DIMY_2D_V1-1)/PRIM_VAR_BLOCK_DIMY_2D_V1, 1)
       call convertToPrimitives<<<dimGrid,dimBlock>>>(data_in)
       call nvtxEndRange()

       ! trace computation: fill arrays d_qm_x, d_qm_y, d_qp_x, d_qp_y
       call nvtxStartRange("computeTrace",3)
       dimBlock = dim3( TRACE_BLOCK_DIMX_2D_V1, TRACE_BLOCK_DIMY_2D_V1, 1 )
       dimGrid  = dim3( &
            & (isize+TRACE_BLOCK_INNER_DIMX_2D_V1-1)/TRACE_BLOCK_INNER_DIMX_2D_V1, &
            & (jsize+TRACE_BLOCK_INNER_DIMY_2D_V1-1)/TRACE_BLOCK_INNER_DIMY_2D_V1, 1)
       call computeTrace<<<dimGrid,dimBlock>>>(d_q,d_qm_x,d_qm_y,d_qp_x,d_qp_y,dt)
       call nvtxEndRange()

       ! Compute flux via Riemann solver and update (time integration)
       call nvtxStartRange("computeFluxAndUpdate",4)
       dimBlock = dim3( UPDATE_BLOCK_DIMX_2D_V1, UPDATE_BLOCK_DIMY_2D_V1, 1 )
       dimGrid  = dim3( &
            & (isize+UPDATE_BLOCK_INNER_DIMX_2D_V1-1)/UPDATE_BLOCK_INNER_DIMX_2D_V1, &
            & (jsize+UPDATE_BLOCK_INNER_DIMY_2D_V1-1)/UPDATE_BLOCK_INNER_DIMY_2D_V1, 1)
       call computeFluxesAndUpdate<<<dimGrid,dimBlock>>>(data_in,data_out,d_qm_x,d_qm_y,d_qp_x,d_qp_y,dt)
       call nvtxEndRange()

    else if (implementationVersion == 2) then

       ! convert conservative variable into primitives ones for the entire domain
       call nvtxStartRange("convertToPrimitives",2)
       dimBlock = dim3( PRIM_VAR_BLOCK_DIMX_2D_V1, PRIM_VAR_BLOCK_DIMY_2D_V1, 1 )
       dimGrid  = dim3( &
            & (isize+PRIM_VAR_BLOCK_DIMX_2D_V1-1)/PRIM_VAR_BLOCK_DIMX_2D_V1, &
            & (jsize+PRIM_VAR_BLOCK_DIMY_2D_V1-1)/PRIM_VAR_BLOCK_DIMY_2D_V1, 1)
       call convertToPrimitives<<<dimGrid,dimBlock>>>(data_in)
       call nvtxEndRange()

       call nvtxStartRange("updateHydro",3)
       dimBlock = dim3( CMP_FLX_STORE_BLOCK_DIMX_2D_V2, CMP_FLX_STORE_BLOCK_DIMY_2D_V2, 1 )
       dimGrid  = dim3( &
            & (isize+CMP_FLX_STORE_BLOCK_DIMX_2D_V2-1)/CMP_FLX_STORE_BLOCK_DIMX_2D_V2, &
            & (jsize+CMP_FLX_STORE_BLOCK_DIMY_2D_V2-1)/CMP_FLX_STORE_BLOCK_DIMY_2D_V2, 1)
       call computeFluxesAndStore<<<dimGrid,dimBlock>>>(data_in, d_fx, d_fy, dt)
       call nvtxEndRange()

       call nvtxStartRange("updateHydro",4)
       dimBlock = dim3( UPDATE_HYDRO_BLOCK_DIMX_2D_V2, UPDATE_HYDRO_BLOCK_DIMY_2D_V2, 1 )
       dimGrid  = dim3( &
            & (isize+UPDATE_HYDRO_BLOCK_DIMX_2D_V2-1)/UPDATE_HYDRO_BLOCK_DIMX_2D_V2, &
            & (jsize+UPDATE_HYDRO_BLOCK_DIMY_2D_V2-1)/UPDATE_HYDRO_BLOCK_DIMY_2D_V2, 1)
       call updateHydro<<<dimGrid,dimBlock>>>(data_in, data_out)
       call nvtxEndRange()

    end if

    call cudaTimerStop(d_godunov_timer)

  end subroutine godunov_unsplit_gpu


  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! Convert conservative variables array into primitive var array (q)
  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  attributes(global) subroutine convertToPrimitives(data_in)

    implicit none

    ! dummy variables
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(in)  :: data_in

    ! local variables
    ! primitive variable state vector
    real(fp_kind), dimension(nbVar) :: uLoc
    real(fp_kind), dimension(nbVar) :: qLoc
    real(fp_kind)                   :: c
    integer :: i,j

    ! Block index
    integer :: bx
    integer :: by

    ! Thread index
    integer :: tx
    integer :: ty

    bx = blockIdx%x
    by = blockIdx%y
    tx = threadIdx%x
    ty = threadIdx%y

    i = (bx-1) * PRIM_VAR_BLOCK_DIMX_2D_V1 + tx
    j = (by-1) * PRIM_VAR_BLOCK_DIMY_2D_V1 + ty


    ! load U and convert to primitive variables
    if (   i <= d_isize .and. &
         & j <= d_jsize        ) then

       ! Gather conservative variables
       uLoc(:) = data_in(i,j,:)

       ! Convert to primitive variables (Array reshaping is not supported for device subprogram calls)
       call constoprim_2d(uLoc, qLoc, c)
       d_q(i,j,:) = qLoc(:)

    end if

  end subroutine convertToPrimitives

  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! Compute trace (only used in implementation version 1), i.e.
  !! fill global array d_qm_x, d_qm_y, d_qp_x, d_qp_y
  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  attributes(global) subroutine computeTrace(q,qm_x,qm_y,qp_x,qp_y,dt)

    implicit none

    ! dummy variables
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: q
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: qm_x
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: qm_y
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: qp_x
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: qp_y
    real(fp_kind), intent(in), value    :: dt

    ! local variables
    integer :: i,j,iVar
    real(fp_kind), dimension(nbVar)   :: qLoc ! local primitive variables
    real(fp_kind), dimension(nbVar)   :: qPlusX
    real(fp_kind), dimension(nbVar)   :: qMinusX
    real(fp_kind), dimension(nbVar)   :: qPlusY
    real(fp_kind), dimension(nbVar)   :: qMinusY
    real(fp_kind), dimension(2,nbVar) :: dq
    real(fp_kind), dimension(2,nbVar) :: qm, qp
    real(fp_kind) :: dtdx
    real(fp_kind) :: dtdy

    ! Block index
    integer :: bx
    integer :: by

    ! Thread index
    integer :: tx
    integer :: ty

    ! primitive variables in shared memory
    real(fp_kind), dimension(TRACE_BLOCK_DIMX_2D_V1, TRACE_BLOCK_DIMY_2D_V1, nbVar), shared :: qSh

    ! set local indexes
    bx = blockIdx%x
    by = blockIdx%y
    tx = threadIdx%x
    ty = threadIdx%y

    i = (bx-1)*TRACE_BLOCK_INNER_DIMX_2D_V1 + tx
    j = (by-1)*TRACE_BLOCK_INNER_DIMY_2D_V1 + ty

    dtdx = dt / d_dx
    dtdy = dt / d_dy

    !
    ! read primitive variables from d_q into shared memory
    !
    if (i <= d_isize .and. j <= d_jsize) then

       qSh(tx,ty,:) = q(i,j,:)

    end if
    call syncthreads()

    !
    ! slopes and trace computation (i.e. dq and then qm,qp)
    !
    if (   i  > 1       .and. j  > 1       .and. &
         & i  < d_isize .and. j  < d_jsize .and. &
         & tx > 1       .and. ty > 1       .and. &
         & tx < TRACE_BLOCK_DIMX_2D_V1     .and. &
         & ty < TRACE_BLOCK_DIMY_2D_V1           ) then


       ! get primitive variables state vector
       qLoc   (:) = qSh(tx  ,ty  ,:)
       qPlusX (:) = qSh(tx+1,ty  ,:)
       qMinusX(:) = qSh(tx-1,ty  ,:)
       qPlusY (:) = qSh(tx  ,ty+1,:)
       qMinusY(:) = qSh(tx  ,ty-1,:)

       ! get hydro slopes dq
       call slope_unsplit_hydro_2d_v2(qLoc, qPlusX, qMinusX, qPlusY, qMinusY, dq)

       ! compute qm, qp
       call trace_unsplit_hydro_2d(qLoc, dq, dtdx, dtdy, qm, qp)

       ! store qm, qp in external memory : only what is really needed
       qm_x(i,j,:) = qm(1,:)
       qp_x(i,j,:) = qp(1,:)
       qm_y(i,j,:) = qm(2,:)
       qp_y(i,j,:) = qp(2,:)

    end if
    call syncthreads()

  end subroutine computeTrace

  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! Compute flux via Riemann solver and update (time integration)
  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  attributes(global) subroutine computeFluxesAndUpdate(data_in,data_out,qm_x,qm_y,qp_x,qp_y,dt)

    implicit none

    ! dummy variables
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: data_in
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: data_out
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: qm_x
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: qm_y
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: qp_x
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: qp_y
    real(fp_kind), intent(in), value    :: dt


    ! local variables
    real(fp_kind), dimension(UPDATE_BLOCK_DIMX_2D_V1, UPDATE_BLOCK_DIMY_2D_V1, nbVar), shared :: flux_x
    real(fp_kind), dimension(UPDATE_BLOCK_DIMX_2D_V1, UPDATE_BLOCK_DIMY_2D_V1, nbVar), shared :: flux_y

    integer :: i,j
    real(fp_kind), dimension(nbVar)     :: uOut
    real(fp_kind), dimension(nbVar)     :: qleft, qright
    !real(fp_kind), dimension(nbVar)     :: flux_x, flux_y
    real(fp_kind), dimension(nbVar)     :: fluxLoc
    real(fp_kind), dimension(nbVar)     :: qgdnv

    real(fp_kind) :: dtdx
    real(fp_kind) :: dtdy

    ! Block index
    integer :: bx
    integer :: by

    ! Thread index
    integer :: tx
    integer :: ty

    ! set local indexes
    bx = blockIdx%x
    by = blockIdx%y
    tx = threadIdx%x
    ty = threadIdx%y

    i = (bx-1)*UPDATE_BLOCK_INNER_DIMX_2D_V1 + tx
    j = (by-1)*UPDATE_BLOCK_INNER_DIMY_2D_V1 + ty

    dtdx = dt / d_dx
    dtdy = dt / d_dy

    flux_x(tx,ty,:) = 0
    flux_y(tx,ty,:) = 0

    ! Gather conservative variables
    uOut(:) = data_in(i,j,:)

    !
    ! Solve Riemann problem at X-interfaces and compute
    ! X-fluxes
    !
    if (   i > ghostWidth  .and. i < d_isize .and. &
         & j > ghostWidth  .and. j < d_jsize       ) then

       qleft(ID)   = qm_x(i-1,j,ID)
       qleft(IP)   = qm_x(i-1,j,IP)
       qleft(IU)   = qm_x(i-1,j,IU)
       qleft(IV)   = qm_x(i-1,j,IV)

       qright(ID)  = qp_x(i  ,j,ID)
       qright(IP)  = qp_x(i  ,j,IP)
       qright(IU)  = qp_x(i  ,j,IU)
       qright(IV)  = qp_x(i  ,j,IV)

       ! compute hydro flux_x
       call riemann_2d(qleft,qright,qgdnv,fluxLoc)
       flux_x(tx,ty,:) = fluxLoc(:)

    end if

    !
    ! Solve Riemann problem at Y-interfaces and compute Y-fluxes
    !
    if (   i > ghostWidth  .and. i < d_isize .and. &
         & j > ghostWidth  .and. j < d_jsize       ) then

       qleft(ID)   = qm_y(i,j-1,ID)
       qleft(IP)   = qm_y(i,j-1,IP)
       qleft(IU)   = qm_y(i,j-1,IV) ! watchout IU, IV permutation
       qleft(IV)   = qm_y(i,j-1,IU) ! watchout IU, IV permutation

       qright(ID)  = qp_y(i,j  ,ID)
       qright(IP)  = qp_y(i,j  ,IP)
       qright(IU)  = qp_y(i,j  ,IV) ! watchout IU, IV permutation
       qright(IV)  = qp_y(i,j  ,IU) ! watchout IU, IV permutation

       ! compute hydro flux_y
       call riemann_2d(qleft,qright,qgdnv,fluxLoc)
       flux_y(tx,ty,:) = fluxLoc(:)

    end if

    ! make sure flux_x and flux_y are computed
    call syncthreads()


    !
    ! update hydro array
    !
    if (   i > ghostWidth .and. i <= d_isize-ghostWidth .and. tx < UPDATE_BLOCK_DIMX_2D_V1 .and. &
         & j > ghostWidth .and. j <= d_jsize-ghostWidth .and. ty < UPDATE_BLOCK_DIMY_2D_V1       ) then


       uOut(ID) = uOut(ID) + flux_x(tx  ,ty,ID)*dtdx
       uOut(ID) = uOut(ID) - flux_x(tx+1,ty,ID)*dtdx

       uOut(IP) = uOut(IP) + flux_x(tx  ,ty,IP)*dtdx
       uOut(IP) = uOut(IP) - flux_x(tx+1,ty,IP)*dtdx

       uOut(IU) = uOut(IU) + flux_x(tx  ,ty,IU)*dtdx
       uOut(IU) = uOut(IU) - flux_x(tx+1,ty,IU)*dtdx

       uOut(IV) = uOut(IV) + flux_x(tx  ,ty,IV)*dtdx
       uOut(IV) = uOut(IV) - flux_x(tx+1,ty,IV)*dtdx

       !! watchout IU and IV are swapped !
       uOut(ID) = uOut(ID) + flux_y(tx,ty  ,ID)*dtdy
       uOut(ID) = uOut(ID) - flux_y(tx,ty+1,ID)*dtdy

       uOut(IP) = uOut(IP) + flux_y(tx,ty  ,IP)*dtdy
       uOut(IP) = uOut(IP) - flux_y(tx,ty+1,IP)*dtdy

       uOut(IU) = uOut(IU) + flux_y(tx,ty  ,IV)*dtdy
       uOut(IU) = uOut(IU) - flux_y(tx,ty+1,IV)*dtdy

       uOut(IV) = uOut(IV) + flux_y(tx,ty  ,IU)*dtdy
       uOut(IV) = uOut(IV) - flux_y(tx,ty+1,IU)*dtdy

       ! copy back data into global memory
       data_out(i,j,:) = uOut(:)

    end if

  end subroutine computeFluxesAndUpdate

  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! Compute flux via Riemann solver and store
  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  attributes(global) subroutine computeFluxesAndStore(data_in,d_fx,d_fy,dt)

    implicit none

    ! dummy variables
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: data_in
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(out) :: d_fx
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(out) :: d_fy
    real(fp_kind), intent(in), value    :: dt


    ! local variables
    integer :: i,j,ivar
    real(fp_kind), dimension(nbVar)     :: qleft, qright
    real(fp_kind), dimension(nbVar)     :: flux_x, flux_y
    real(fp_kind), dimension(nbVar)     :: qgdnv
    real(fp_kind), dimension(nbVar)     :: qLoc, qLocN, qN0, qN1, qN2, qN3
    real(fp_kind), dimension(2,nbVar)   :: dq, dqN

    real(fp_kind) :: tmp

    real(fp_kind) :: dtdx
    real(fp_kind) :: dtdy

    ! Block index
    integer :: bx
    integer :: by

    ! Thread index
    integer :: tx
    integer :: ty

    ! set local indexes
    bx = blockIdx%x
    by = blockIdx%y
    tx = threadIdx%x
    ty = threadIdx%y

    i = (bx-1)*CMP_FLX_STORE_BLOCK_DIMX_2D_V2 + tx
    j = (by-1)*CMP_FLX_STORE_BLOCK_DIMY_2D_V2 + ty

    dtdx = dt / d_dx
    dtdy = dt / d_dy

    if (   i <= d_isize   .and. j <= d_jsize .and. &
         & i > ghostWidth .and. j >  ghostWidth) then


       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       !! deal with left interface along X !
       !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

       !! get primitive variables state vector
       do ivar=1,nbVar
          qLoc(ivar) = d_q(i  ,j  , ivar)
          qN0(ivar)  = d_q(i+1,j  , ivar)
          qN1(ivar)  = d_q(i-1,j  , ivar)
          qN2(ivar)  = d_q(i  ,j+1, ivar)
          qN3(ivar)  = d_q(i  ,j-1, ivar)
       end do

       call slope_unsplit_hydro_2d_v2(qLoc, qN0, qN1, qN2, qN3, dq)

       ! slopes at left neighbor along X
       do ivar=1,nbVar
          qLocN(ivar) = d_q(i-1,j  , ivar)
          qN0(ivar)   = d_q(i  ,j  , ivar)
          qN1(ivar)   = d_q(i-2,j  , ivar)
          qN2(ivar)   = d_q(i-1,j+1, ivar)
          qN3(ivar)   = d_q(i-1,j-1, ivar)
       end do

       call slope_unsplit_hydro_2d_v2(qLocN, qN0, qN1, qN2, qN3, dqN)

       !
       ! compute reconstructed states at left interface along X
       !

       ! left interface : right state
       call trace_unsplit_2d_along_dir(qLoc, dq, dtdx, dtdy, FACE_XMIN, qright)

       ! left interface : left state
       call trace_unsplit_2d_along_dir(qLocN, dqN, dtdx, dtdy, FACE_XMAX, qleft)

       ! compute hydro flux_x
       call riemann_2d(qleft,qright,qgdnv,flux_x)

       !
       ! store fluxes X
       !
       do ivar=1,nbVar
          d_fx(i  ,j  , ivar) = flux_x(ivar) * dtdx
       end do

       !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       !! deal with left interface along Y !
       !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

       !! slopes at left neighbor along Y
       do ivar=1,nbVar
          qLocN(ivar) = d_q(i  ,j-1, ivar)
          qN0(ivar)   = d_q(i+1,j-1, ivar)
          qN1(ivar)   = d_q(i-1,j-1, ivar)
          qN2(ivar)   = d_q(i  ,j  , ivar)
          qN3(ivar)   = d_q(i  ,j-2, ivar)
       end do

       call slope_unsplit_hydro_2d_v2(qLocN, qN0, qN1, qN2, qN3, dqN)

       !!
       !! compute reconstructed states at left interface along Y
       !!

       !! left interface : right state
       call trace_unsplit_2d_along_dir(qLoc, dq, dtdx, dtdy, FACE_YMIN, qright)

       !! left interface : left state
       call trace_unsplit_2d_along_dir(qLocN, dqN, dtdx, dtdy, FACE_YMAX, qleft)

       ! swap IU / IV
       tmp = qleft(IU); qleft(IU) = qleft(IV); qleft(IV) = tmp
       tmp = qright(IU); qright(IU) = qright(IV); qright(IV) = tmp

       ! compute hydro flux_y
       call riemann_2d(qleft,qright,qgdnv,flux_y)

       tmp = flux_y(IU); flux_y(IU) = flux_y(IV); flux_y(IV) = tmp

       !
       ! store fluxes Y
       !
       do ivar=1,nbVar
          d_fy(i  ,j  , ivar) = flux_y(ivar) * dtdy
       end do

    end if

  end subroutine computeFluxesAndStore

  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! Update with hydro fluxes
  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  attributes(global) subroutine updateHydro(data_in,data_out)

    implicit none

    ! dummy variables
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(in)  :: data_in
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(out) :: data_out

    ! local variables
    ! primitive variable state vector
    integer :: i,j,ivar
    real(fp_kind) :: flux_tot

    ! Block index
    integer :: bx
    integer :: by

    ! Thread index
    integer :: tx
    integer :: ty

    bx = blockIdx%x
    by = blockIdx%y
    tx = threadIdx%x
    ty = threadIdx%y

    i = (bx-1) * UPDATE_HYDRO_BLOCK_DIMX_2D_V2 + tx
    j = (by-1) * UPDATE_HYDRO_BLOCK_DIMY_2D_V2 + ty


    ! load U (at t) and update U2 (at t+ dt)
    if (   i <= d_isize .and. &
         & j <= d_jsize        ) then

       do ivar=1,nbVar
          flux_tot  = d_fx(i  ,j  ,ivar) - d_fx(i+1,j  ,ivar)
          flux_tot  = d_fy(i  ,j  ,ivar) - d_fy(i  ,j+1,ivar) + flux_tot
          data_out(i, j, ivar) = data_in(i, j, ivar) + flux_tot
       end do

    end if

  end subroutine updateHydro

  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! Hydrodynamical Implosion Test :
  !! http://www.astro.princeton.edu/~jstone/tests/implode/Implode.html
  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine init_implode(data)

    implicit none

    ! dummy variables
    real(fp_kind), dimension(isize, jsize, nbVar), intent(inout) :: data

    ! local variables
    integer :: i,j
    real(fp_kind) :: tmp

    do j=1,jsize
       do i=1,isize
          tmp = 1.0*(i-ghostWidth-1)/nx + 1.0*(j-ghostWidth-1)/ny
          if (tmp .gt. 0.5) then
             data(i,j,ID)=1.0+tmp
             data(i,j,IP)=1.0/(gamma0-1.0)
             data(i,j,IU)=0.0
             data(i,j,IV)=0.0
          else
             data(i,j,ID)=0.125+tmp
             data(i,j,IP)=0.14/(gamma0-1.0)
             data(i,j,IU)=0.0
             data(i,j,IV)=0.0
          end if
       end do
    end do

  end subroutine init_implode

  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! output routine (VTK file format, ASCII, VtkImageData)
  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine saveVTK(data,iStep)
    implicit none
    ! dummy variables
    real   (fp_kind), dimension(isize, jsize, nbVar), intent(inout) :: data
    integer(int_kind) :: iStep

    ! local variables
    integer :: j,iVar
    integer :: error
    character(LEN=80) :: filename
    character(LEN=8)  :: filenum
    character(1), parameter :: endl  = char(10)  ! end of line
    character(500) :: charBuf
    character(7) :: floatType

    if (useDoublePrecision()) then
       write(floatType,'(a)') 'Float64'
    else
       write(floatType,'(a)') 'Float32'
    end if
    write (filenum,'(i8.8)') iStep
    filename='euler2d_' // filenum // '.vti'

    !open(10,file=filename,status='replace',form='unformatted',action='write',iostat=error)
    !open(10,file=filename,status='replace',access='stream',action='write',iostat=error)
    open(10,file=filename,iostat=error)

    ! write header
    write(10,'(a)') '<?xml version="1.0"?>'//endl
    if (isBigEndian()) then
       write(10,'(a)') '<VTKFile type="ImageData" version="0.1" byte_order="BigEndian">'//endl
    else
       write(10,'(a)') '<VTKFile type="ImageData" version="0.1" byte_order="LittleEndian">'//endl
    end if

    ! write mesh extent
    write(charBuf,fmt='(6(I7))',iostat=error) 1,nx+1,1,ny+1,1,2
    write(10,'(a)') repeat(' ',2)//'<ImageData WholeExtent="'//trim(charBuf)//'"'
    write(10,'(a)') ' Origin="0 0 0" Spacing="1 1 1">'//endl
    write(10,'(a)') repeat(' ',2)//'<Piece Extent="'//trim(charBuf)//'">'//endl

    write(10,'(a)') repeat(' ',3)//'<PointData>'//endl
    write(10,'(a)') repeat(' ',4)//'</PointData>'//endl
    write(10,'(a)') repeat(' ',4)//'<CellData>'//endl

    ! write data array (ascii), remove ghost cells
    do iVar=1,nbVar
       write(10,'(a)') repeat(' ',4)//'<DataArray type="'//trim(floatType)// &
            & '" Name="'//varNames(iVar)//'" format="ascii" >'//endl

       do j=ghostWidth+1,jsize-ghostWidth
          write(10,*) data(ghostWidth+1:isize-ghostWidth,j,iVar)
       end do

       write(10,'(a)') repeat(' ',4)//'</DataArray>'//endl
    end do

    ! write footer
    write(10,'(a)') repeat(' ',4)//'</CellData>'//endl
    write(10,'(a)') repeat(' ',2)//'</Piece>'//endl
    write(10,'(a)') repeat(' ',2)//'</ImageData>'//endl
    write(10,'(a)') '</VTKFile>'//endl

    close(10)

  end subroutine saveVTK

  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! Fill ghost cells according to border condition :
  !! absorbant, reflexive or periodic
  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  subroutine make_boundaries_gpu(data)
    implicit none
    ! dummy variables
    real(fp_kind), dimension(isize, jsize, nbVar), intent(inout), device :: data

    ! local variables
    integer ::i,j,i0,j0,iVar
    real(fp_kind) :: sign

    !! take care to reverse loop order

    call nvtxStartRange("make_boundaries",5)

    ! boundary xmin
    !$cuf kernel do(1) <<< *, 128 >>>
    do j=ghostWidth+1,jsize-ghostWidth
       do iVar=1,nbVar
          do i=1,ghostWidth
             sign=1.0
             if(boundary_type_xmin==1)then
                i0=2*ghostWidth+1-i
                if(iVar==IU)sign=-1.0
             else if(boundary_type_xmin==2)then
                i0=ghostWidth+1
             else ! periodic
                i0=nx+i
             end if
             data(i,j,iVar)=data(i0,j,iVar)*sign
          end do
       end do
    end do

    ! boundary xmax
    !$cuf kernel do(1) <<< *, 128 >>>
    do j=ghostWidth+1,jsize-ghostWidth
       do iVar=1,nbVar
          do i=nx+ghostWidth+1,nx+2*ghostWidth
             sign=1.0
             if(boundary_type_xmax==1)then
                i0=2*nx+2*ghostWidth+1-i
                if(iVar==IU)sign=-1.0
             else if(boundary_type_xmax==2)then
                i0=nx+ghostWidth
             else ! periodic
                i0=i-nx
             end if
             data(i,j,iVar)=data(i0,j,iVar)*sign
          end do
       end do
    end do

    ! boundary ymin
    !$cuf kernel do(1) <<< *, 128 >>>
    do i=ghostWidth+1,isize-ghostWidth
       do iVar=1,nbVar
          do j=1,ghostWidth
             sign=1.0
             if(boundary_type_ymin==1)then
                j0=2*ghostWidth+1-j
                if(iVar==IV)sign=-1.0
             else if(boundary_type_ymin==2)then
                j0=ghostWidth+1
             else ! periodic
                j0=ny+j
             end if
             data(i,j,iVar)=data(i,j0,iVar)*sign
          end do
       end do
    end do

    ! boundary ymax
    !$cuf kernel do(1) <<< *, 128 >>>
    do i=ghostWidth+1,isize-ghostWidth
       do iVar=1,nbVar
          do j=ny+ghostWidth+1,ny+2*ghostWidth
             sign=1.0
             if(boundary_type_ymax==1)then
                j0=2*ny+2*ghostWidth+1-j
                if(iVar==IV)sign=-1.0
             else if(boundary_type_ymax==2)then
                j0=ny+ghostWidth
             else ! periodic
                j0=j-ny
             end if
             data(i,j,iVar)=data(i,j0,iVar)*sign
          end do
       end do
    end do

    call nvtxEndRange()

  end subroutine make_boundaries_gpu

  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  !! define CUDA kernels...
  !! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  attributes(global) subroutine kernel_godunov_unsplit_2d_v0(data_in, data_out, dt)

    implicit none

    ! dummy variables
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: data_in
    real(fp_kind), dimension(d_isize, d_jsize, nbVar), intent(inout) :: data_out
    real(fp_kind), intent(in), value                                 :: dt

    ! local variables

    ! Block index
    integer :: bx
    integer :: by

    ! Thread index
    integer :: tx
    integer :: ty

    ! other variables
    integer :: i,j
    real(fp_kind) :: dtdx
    real(fp_kind) :: dtdy
    real(fp_kind) :: tmp

    ! primitives variables
    real(fp_kind), dimension(UNSPLIT_BLOCK_DIMX_2D, UNSPLIT_BLOCK_DIMY_2D, nbVar), shared :: q

    ! flux along y
    real(fp_kind), dimension(UNSPLIT_BLOCK_DIMX_2D, UNSPLIT_BLOCK_DIMY_2D, nbVar), shared :: flux_y


    real(fp_kind), dimension(2, nbVar) :: qm, qp, qp0
    real(fp_kind), dimension(nbVar)    :: qm1, qm2

    real(fp_kind)                      :: c, cPlus, cMinus
    integer                            :: pos

    real(fp_kind), dimension(nbVar)    :: uIn, uOut, qLoc, qgdnv, flux, qleft, qright
    real(fp_kind), dimension(4,nbVar)  :: qNeighbors


    bx = blockIdx%x
    by = blockIdx%y
    tx = threadIdx%x
    ty = threadIdx%y

    i = (bx-1)*UNSPLIT_BLOCK_INNER_DIMX_2D + tx
    j = (by-1)*UNSPLIT_BLOCK_INNER_DIMY_2D + ty

    dtdx = dt / d_dx
    dtdy = dt / d_dy

    ! load U and convert to primitive variables
    if (   i <= d_isize .and. &
         & j <= d_jsize        ) then

       ! Gather conservative variables
       uIn(:) = data_in(i,j,:)

       ! copy input state into uOut that will become output state
       uOut(:) = uIn(:)

       ! Convert to primitive variables (Array reshaping is not supported for device subprogram calls)
       call constoprim_2d(uIn, qLoc, c)
       q(tx,ty,:) = qLoc(:)

    end if
    call syncthreads()


    if (   i > 2 .and. i <= d_isize-1 .and. tx>2 .and. tx<UNSPLIT_BLOCK_DIMX_2D .and. &
         & j > 2 .and. j <= d_jsize-1 .and. ty>2 .and. ty<UNSPLIT_BLOCK_DIMY_2D) then

       ! Characteristic tracing : compute qp0
       qNeighbors(1,:) = q(tx+1,ty  ,:)
       qNeighbors(2,:) = q(tx-1,ty  ,:)
       qNeighbors(3,:) = q(tx  ,ty+1,:)
       qNeighbors(4,:) = q(tx  ,ty-1,:)

       qLoc = q(tx,ty,:)
       call trace_unsplit_2d(qLoc, qNeighbors, dtdx, dtdy, qm, qp0)

       ! Characteristic tracing : compute qm_x[1]
       qNeighbors(1,:) = q(tx  ,ty  ,:)
       qNeighbors(2,:) = q(tx-2,ty  ,:)
       qNeighbors(3,:) = q(tx-1,ty+1,:)
       qNeighbors(4,:) = q(tx-1,ty-1,:)

       qLoc = q(tx-1,ty,:)
       call trace_unsplit_2d(qLoc, qNeighbors, dtdx, dtdy, qm, qp)
       qm1(:) = qm(1,:)

       ! Characteristic tracing : compute qm_y[2]
       qNeighbors(1,:) = q(tx+1,ty-1,:)
       qNeighbors(2,:) = q(tx-1,ty-1,:)
       qNeighbors(3,:) = q(tx  ,ty  ,:)
       qNeighbors(4,:) = q(tx  ,ty-2,:)

       qLoc = q(tx,ty-1,:)
       call trace_unsplit_2d(qLoc, qNeighbors, dtdx, dtdy, qm, qp)
       qm2(:) = qm(2,:)

    end if
    call syncthreads()

    !!!! re-use q as flux_x !!!!
    q(tx,ty,:)=0
    call syncthreads()

    if(    i  > ghostWidth .and. i  <= d_isize-1             .and. &
         & tx > ghostWidth .and. tx < UNSPLIT_BLOCK_DIMX_2D  .and. &
         & j  > ghostWidth .and. j  <= d_jsize-1             .and. &
         & ty > ghostWidth .and. ty < UNSPLIT_BLOCK_DIMY_2D) then

       ! Solve Riemann problem at X-interfaces and compute fluxes
       qleft  = qm1
       qright = qp0(1,:)
       call riemann_2d(qleft, qright, qgdnv, flux)
       q(tx,ty,:) = flux

       ! Solve Riemann problem at Y-interfaces and compute fluxes
       qleft  = qm2
       qright = qp0(2,:)

       ! watchout swap IU and IV
       tmp = qleft(IU)  ; qleft(IU)  = qleft(IV)  ; qleft(IV)  = tmp
       tmp = qright(IU) ; qright(IU) = qright(IV) ; qright(IV) = tmp
       call riemann_2d(qleft, qright, qgdnv, flux)
       flux_y(tx,ty,:) = flux

    end if
    call syncthreads()

    if(    i  > ghostWidth .and. i  <= d_isize-ghostWidth               .and. &
         & tx > ghostWidth .and. tx <= UNSPLIT_BLOCK_DIMX_2D-ghostWidth .and. &
         & j  > ghostWidth .and. j  <= d_jsize-ghostWidth               .and. &
         & ty > ghostWidth .and. ty <= UNSPLIT_BLOCK_DIMY_2D-ghostWidth) then

      ! update U with flux_x
      uOut(ID) = uOut(ID) + (q(tx,ty,ID)-q(tx+1,ty,ID))*dtdx
      uOut(IP) = uOut(IP) + (q(tx,ty,IP)-q(tx+1,ty,IP))*dtdx
      uOut(IU) = uOut(IU) + (q(tx,ty,IU)-q(tx+1,ty,IU))*dtdx
      uOut(IV) = uOut(IV) + (q(tx,ty,IV)-q(tx+1,ty,IV))*dtdx

      ! update U with flux_y : watchout! IU and IV are swapped !
      uOut(ID) = uOut(ID) + (flux_y(tx,ty,ID)-flux_y(tx,ty+1,ID))*dtdy
      uOut(IP) = uOut(IP) + (flux_y(tx,ty,IP)-flux_y(tx,ty+1,IP))*dtdy
      uOut(IU) = uOut(IU) + (flux_y(tx,ty,IV)-flux_y(tx,ty+1,IV))*dtdy
      uOut(IV) = uOut(IV) + (flux_y(tx,ty,IU)-flux_y(tx,ty+1,IU))*dtdy

      ! actually perform update on external device memory
      data_out(i,j,:) = uOut(:)

   end if

  end subroutine kernel_godunov_unsplit_2d_v0

end module HydroRun_gpu
